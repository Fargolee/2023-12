## 正则表达式

## 一、概述

### 1\. 概念

正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。

### 2\. 目的

给定一个正则表达式和另一个字符串，我们可以达到如下的目的：

-   a. 给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）；
    
    例如：邮箱匹配，电话号码匹配
    
-   b. 可以通过正则表达式，从字符串中获取我们想要的特定部分。
    
    爬虫中解析 HTML 数据
    

### 3\. 特点：

-   a. 灵活性、逻辑性和功能性非常的强；
-   b. 可以迅速地用极简单的方式达到字符串的复杂控制。
-   c. 对于刚接触的人来说，比较晦涩难懂。

### 4\. 学习方法

-   a. 做好笔记，不要死记硬背
-   b. 大量练习

**python 中通过系统库 re 实现正则表达式的所有功能**

## 二、正则表达式符号

### 1\. 普通字符

下面的案例使用 `re` 模块的 `findall()` 函数，函数参考如下：

-   ```
    re.findall(pattern, string, flag)
    ```
    
    Python
    
    -   在字符串中找到正则表达式所匹配的所有子串，并返回列表，如果没有找到返回空列表
    -   `pattern`: 正则表达式
    -   `string`：被匹配的字符串
    -   `flag`：标志位用来控制正则表达式匹配方式

在最简单的情况下，一个正则表达式看上去就是一个普通的查找串

```
import re
s1 = "testing123"
s2 = "Testing123"
r = re.findall("test", s1)  # 表示在s1中找到字符串"test"
print(r)  
```

运行结果：

```
['test']
```

```
r = re.findall("test", s2)
print(r)  
```

运行结果：

```
[]
```

```
r = re.findall("test", s2, re.I) # 修饰符re.I:使匹配对大小写不敏感
print(r)  
```

运行结果：

```
['Test']
```

### 2\. 元字符

```
. ^ $ * + ? { } [ ] | ( ) \
```

符号

功能

.

通配符 `.` **匹配除 `\n` 之外的任何单个字符**

^

脱字符 `^` **匹配输入字符串的开始位置**

$

美元符 `$` **匹配输入字符串的结束位置**

\*

重复元字符 `*` 匹配前面的子表达式任意次

+

重复元字符 `+` 匹配前面的子表达式一次或多次（至少一次）

?

重复元字符 `?` 匹配前面的子表达式 0 次或 1 次

 

重复元字符`{}`**也是控制匹配前面的子表达式次数**

\[ \]

字符组 `[]`**表示匹配给出的任意字符**

|

选择元字符 \`

( )

分组元字符 `()`**将括号之间的表达式定义为组(group)，并且将匹配这个子表达式的字符返回**

\\

转义元字符 `\` **用来匹配元字符本身时的转义，和特定字符组成字符串，见预定义字符组**

#### 2.1 通配符 `.`

**匹配除 `\n` 之外的任何单个字符**

```
s1 = "testing123"
s2 = "testing123\n"
r = re.findall(".", s1)
print(r)
```

运行结果：

```
['t', 'e', 's', 't', 'i', 'n', 'g', '1', '2', '3']
```

```
r = re.findall(".", s2)  # 除“\n”
print(r)
```

运行结果：

```
['t', 'e', 's', 't', 'i', 'n', 'g', '1', '2', '3']
```

修饰符 `re.S` 使 `.` 匹配包括换行在内的所有字符

```
r = re.findall(".", s2, re.S)  
print(r)
```

运行结果：

```
['t', 'e', 's', 't', 'i', 'n', 'g', '1', '2', '3', '\n']
```

#### 2.2 脱字符 `^`

**匹配输入字符串的开始位置**

```
s1 = "testing\nTesting\ntest"

r = re.findall("^test", s1)  # 默认只匹配单行
print(r)
```

运行结果：

```
['test']
```

```
r = re.findall("^test", s1, re.M)   # 修饰符re.M:多行匹配
print(r)  
```

运行结果：

```
['test', 'test']
```

```
r = re.findall("^test", s1, re.I | re.M)  
print(r)  # 输出['test', 'Test', 'test']
```

运行结果：

```
['test', 'Test', 'test']
```

#### 2.3 美元符 `$`

**匹配输入字符串的结束位置**

```
s1 = "testing\nTesting\ntest"
r = re.findall("testing$", s1)  # 默认匹配单行
print(r)  
```

运行结果：

```
[]
```

```
r = re.findall("testing$", s1, re.M)   # 修饰符re.M:多行匹配
print(r)  # 输出['testing']
```

运行结果：

```
['testing']
```

```
r = re.findall("testing$", s1, re.I | re.M)    # 多个修饰符通过 OR(|) 来指定
print(r)  # 输出['testing', 'Testing']
```

运行结果：

```
['testing', 'Testing']
```

#### 2.4 重复元字符 `*,+,?`

-   `*` 匹配前面的子表达式任意次
-   `+` 匹配前面的子表达式一次或多次（至少一次）
-   `?` 匹配前面的子表达式 0 次或 1 次

```
s1 = "z\nzo\nzoo"
r = re.findall("zo*", s1)     # 匹配o{0，}
print(r)  
```

运行结果：

```
['z', 'zo', 'zoo']
```

```
r = re.findall("zo+", s1)   # 匹配o{1，}
print(r)  
```

运行结果：

```
['zo', 'zoo']
```

```
r = re.findall("zo?", s1)    # 匹配o{0，1}
print(r)  
```

运行结果：

```
['z', 'zo', 'zo']
```

#### 2.5 重复元字符 `{}`

**也是控制匹配前面的子表达式次数**

```
s1 = "z\nzo\nzoo"
r = re.findall("zo*", s1)     # 匹配o{0,},逗号后不能空格
r1 = re.findall(r"zo{0,}", s1)
print(r)  # ['z', 'zo', 'zoo']
print(r1)  # ['z', 'zo', 'zoo']
```

运行结果：

```
['z', 'zo', 'zoo']
['z', 'zo', 'zoo']
```

```
r = re.findall("zo+", s1)   # 匹配o{1，}
r1 = re.findall(r"zo{1,}", s1)
print(r)  # 输出['zo', 'zoo']
print(r1)  # 输出['zo', 'zoo']
```

运行结果：

```
['zo', 'zoo']
['zo', 'zoo']
```

```
r1 = re.findall("zo{2}", s1)  
print(r1)  # 输出['zoo']
```

运行结果：

```
['zoo']
```

#### 2\. 6 字符组 `[]`

**表示匹配给出的任意字符**

```
s1 = "吴建国\n李建国\n黄建国"

r = re.findall("[黄刘李]建国", s1)   # 匹配包含的任意字符
print(r)  
```

运行结果：

```
['李建国', '黄建国']
```

```
s1 = "test\nTesting\nzoo"
r = re.findall("[e-o]", s1)   # 匹配包含的字符范围
print(r)  
```

运行结果：

```
['e', 'e', 'i', 'n', 'g', 'o', 'o']
```

```
s1 = "test\nTesting\nzoo"
r = re.findall("^[tz]", s1, re.M)   # 回忆脱字符，匹配以[tz]开头字符。
print(r)  
```

运行结果：

```
['t', 'z']
```

```
s1 = "吴建国\n李建国\n黄建国"
r = re.findall("[^黄刘李]建国", s1)    # ^放到[]的里面，表示排除
print(r) 
```

运行结果：

```
['吴建国']
```

```
s1 = "test\nTesting\nzoo"
r1 = re.findall("[^e-o]", s1)    # 匹配未包含的字符范围
print(r1)  # 输出['t', 's', 't', '\n', 'T', 's', 't', '\n', 'z']
['t', 's', 't', '\n', 'T', 's', 't', '\n', 'z']
```

#### 2.7 选择元字符 `|`

表示两个表达式选择一个匹配

```
s1 = "z\nzood\nfood"
r = re.findall("z|food", s1)   # 匹配"z"或"food"
print(r) 
```

运行结果：

```
['z', 'z', 'food']
```

```
r = re.findall("[z|f]ood", s1)   # 匹配"zood"或"food"
print(r)  # 
```

运行结果：

```
['zood', 'food']
```

#### 2.8 分组元字符 `()`

**将括号之间的表达式定义为组(group)，并且将匹配这个子表达式的字符返回**

```
s1 = "z\nzood\nfood"
r = re.findall("[z|f]o*", s1)   # 不加分组，拿到的引号内正则表达式匹配到的字符
print(r)
```

运行结果：

```
['z', 'zoo', 'foo']
```

```
r = re.findall("[z|f](o*)", s1)   # 加上分组，返回的将是引号内正则表达式匹配到的字符中（）中的内容。
print(r)  # ['', 'oo', 'oo']
```

运行结果：

```
['', 'oo', 'oo']
```

#### 2.9 转义元字符 `\`

**用来匹配元字符本身时的转义，和特定字符组成字符串，见预定义字符组**

```
s = '12345@qq.com'
r = re.findall('\.', s)
print(r)
```

运行结果：

```
['.']
```

#### 2.10 非贪婪模式

##### 非贪婪模式

在默认情况下，元字符 \*,+ 和 {n,m} 会尽可能多的匹配前面的子表达式，这叫贪婪模式。

```
s = "abcadcaec"

r = re.findall(r"ab.*c", s)   # 贪婪模式，尽可能多的匹配字符(.*或者.+)
print(r) 
```

```
['abcadcaec']
```

在重复元字符后面加上一个?号就表示非贪婪，尽可能少的匹配

```
r = re.findall(r"ab.+?c", s)   # 非贪婪模式，尽可能少的匹配字符
print(r) 
```

```
['abcadc']
```

```
r = re.findall(r"ab.*?c", s)   # 非贪婪模式，尽可能少的匹配字符
print(r) 
```

```
['abc']
```

```
s = "<a href=' asdf'>1360942725</a>"
a = re.findall('\d', s)
print(a) 
```

```
['1', '3', '6', '0', '9', '4', '2', '7', '2', '5']
```

```
a = re.findall('\D', s)
print(a)
```

```
['<', 'a', ' ', 'h', 'r', 'e', 'f', '=', "'", ' ', 'a', 's', 'd', 'f', "'", '>', '<', '/', 'a', '>']
```

```
s = 'fdfa**68687+ 我怕n fdg\tf_d\n'
a = re.findall('\s', s)
print(a)  
```

```
[' ', ' ', '\t', '\n']
```

```
a = re.findall("\w", s)
print(a)
```

```
['f', 'd', 'f', 'a', '6', '8', '6', '8', '7', '我', '怕', 'n', 'f', 'd', 'g', 'f', '_', 'd']
```

### 3\. 预定义字符组

元字符 `\` 与某些字符组合在一起表示特定的匹配含义

#### 3.1 `\d`

**匹配单个数字，等价于\[0-9\]**

```
s = "<a href=' asdf'>1360942725</a>"
a = re.findall('\d', s)
print(a) 
```

运行结果：

```
['1', '3', '6', '0', '9', '4', '2', '7', '2', '5']
```

```
a = re.findall('\d+', s)
print(a)  
```

运行结果：

```
['1360942725']
```

#### 3.2 `\D`

**匹配任意单个非数字字符，等价于\[^0-9\]**

```
a = re.findall('\D', s)
print(a)
```

运行结果：

```
['<', 'a', ' ', 'h', 'r', 'e', 'f', '=', "'", ' ', 'a', 's', 'd', 'f', "'", '>', '<', '/', 'a', '>']
```

#### 3.3 `\s`

**匹配任意单个空白符，包括空格，制表符(tab)，换行符等**

```
s = 'fdfa**68687+ 我怕n fdg\tf_d\n'
a = re.findall('\s', s)
print(a)  
```

运行结果：

```
[' ', ' ', '\t', '\n']
```

3.4 `\S`

**匹配任何非空白字符**

```
s = 'fdfa**68687+ 我怕n fdg\tf_d\n'
a = re.findall('\S', s)
print(a) 
```

运行结果：

```
['f', 'd', 'f', 'a', '', '', '6', '8', '6', '8', '7', '+', '我', '怕', 'n', 'f', 'd', 'g', 'f', '_', 'd']
```

3.5 `\w`

**匹配除符号外的单个字母，数字，下划线或汉字等**

```
a = re.findall("\w", s)
print(a)
```

运行结果：

```
['f', 'd', 'f', 'a', '6', '8', '6', '8', '7', '我', '怕', 'n', 'f', 'd', 'g', 'f', '_', 'd']
```

Bash

元字符

说明

.

匹配除换行符以外的任意字符

\\w

匹配字母或数字或下划线

\\W

和 \\w 相反

\\d

匹配数字

\\D

和 \\d 相反

\\s

匹配任意的空白符

\\S

和 \\s 相反

小案例

1.  检测邮箱

```
s = "3003756995@qq.com"
a = re.findall('^\w+@\w+\.com$', s) # 检测邮箱
if a:
    print('是正确格式的邮箱')
else:
    print('不是邮箱地址')
```

是正确格式的邮箱

2.  检测手机号码

```
s = '13812345678'
r = re.findall('^1[3-9]\d{9}$', s)  # 检查手机号码
if r:
    print('手机号码格式正确')
else:
    print('手机号码格式不正确')
  
```

手机号码格式正确

### [4.re](http://4.re/) 模块常用函数

#### 4.1 `re.match`

-   ```
    re.match(pattern, string, flag)
    ```
    
    Plain text
    
    -   尝试从字符串的起始位置匹配一个模式，成功返回匹配对象，否则返回 None
    -   `pattern`: 正则表达式
    -   `string`: 被匹配的字符串
    -   `flag`: 标志位，表示匹配模式

```
import re
url = 'www.hhxpython.com'
res = re.match('www', url)    # 'www' 就是正则表达式，没有元字符表示匹配字符本身
                              # re.match默认是从字符串开头匹配，等价于'^www'
print(res)
```

运行结果：

```
<re.Match object; span=(0, 3), match='www'>
```

```
res2 = re.match('hhx', url)
print(res2)
```

运行结果：

```
None
```

**匹配对象**

`match` 函数返回一个匹配对象，通过这个对象可以取出匹配到的字符串和分组字符串

```
line = 'Good good study, Day day up!'
match_obj = re.match('(?P<aa>.*), (.*) (.*)', line)  
if match_obj: 
    print(match_obj.group())    # 返回匹配到的字符串
    print(match_obj.group(1))   # 返回对应序号分组字符串 从1开始
    print(match_obj.group(2))
    print(match_obj.group(3))
else:
    print('not found')
print(match_obj.groups())  # 返回分组字符串元组
print(match_obj.groupdict())  # 按照分组名和分组字符串组成字典 (?P<name>pattern)
```

运行结果：

```
Good good study, Day day up!
Good good study
Day day
up!
('Good good study', 'Day day', 'up!')
{'aa': 'Good good study'}
```

#### 4.2 `re.search`

-   ```
    re.search(pattern, string, flag)
    ```
    
    Plain text
    
    -   扫描整个字符串返回第一个成功的匹配对象
    -   `pattern`: 正则表达式
    -   `string`: 被匹配的字符串
    -   `flag`: 标志位，表示匹配模式

```
url = 'www.hhxpython.com'
res = re.search('www', url)    # 'www' 就是正则表达式，没有元字符表示匹配字符本身
print(res)
```

运行结果：

```
<re.Match object; span=(0, 3), match='www'>
```

```
res2 = re.search('hhx', url)
print(res2)
```

运行结果：

```
<re.Match object; span=(4, 7), match='hhx'>
```

```
res3 = re.search('h', url)
print(res3)
```

运行结果：

```
<re.Match object; span=(4, 5), match='h'>
```

#### 4.3 `re.sub`

-   ```
    re.sub(pattern, repl, string, count=0, flag)
    ```
    
    Plain text
    
    -   将表达式匹配到的部分替换为制定字符串，返回替换后的新字符串
    -   `pattern`: 正则表达式
    -   `repl`: 用来替换的字符串
    -   `string`: 被匹配的字符串
    -   `count`: 替换次数，默认为 0，表示全部替换
    -   `flags`: 标志位，表示匹配模式

```
phone = '2004-959-559 # 这是一个国外电话号码'

# 删除字符串中的python注释
num = re.sub('#.*', '', phone)
print(num)
```

运行结果：

```
2004-959-559
# 删除连接符号 -
num = re.sub('-', '', num)
print(num)
```

运行结果：

```
2004959559
```

#### 4.4 `re.findall`

-   ```
    re.findall(pattern, string, flags=0)
    ```
    
    Plain text
    
    -   在字符串中找到正则表达式匹配的所有子串，返回一个列表，匹配失败则返回空列表
    -   `pattern`: 正则表达式
    -   `string`: 被匹配的字符串
    -   `flags`: 标志位，表示匹配模式

```
res1 = re.findall('day', line, re.I)
res2 = re.search('day', line, re.I)
res3 = re.match('day', line, re.I)

print('findall', res1)
print('search', res2.group())
print('search', res3)
```

运行结果：

```
findall ['Day', 'day']
search Day
search None
```

##### `match`,`search`,`findall` 的区别

-   `match` 从头开始匹配，成功返回匹配对象，失败返回 None
-   `search` 只匹配第一个，成功返回匹配对象，失败返回 None
-   `findall` 匹配所有，成功返回所有匹配到的字符串组成的列表，失败返回空列表

#### 4.5 `re.compile`

-   ```
    re.compile(pattern, [flags])
    ```
    
    Plain text
    
    -   compile 函数用于编译正则表达式，生成一个正则表达式对象，该对象调用 findall，search，match，sub 等方法
    -   `pattern`: 正则表达式
    -   `flags`: 标志位，表示匹配模式
        面向对象编程时使用

```
pattern = re.compile('day', re.I)
res1 = pattern.findall(line)
res2 = pattern.search(line)
res3 = pattern.match(line)
print('findall', res1)
print('search', res2.group())
print('match', res3)
```

运行结果：

```
findall ['Day', 'day']
search Day
match None
```

## 三、正则表达式超全速查手册

### 校验数字的表达式

数字：`^[0-9]*$`

n位的数字：`^\d{n}$`

至少n位的数字：`^\d{n,}$`

m-n位的数字：`^\d{m,n}$`

零和非零开头的数字：`^(0|[1-9][0-9]*)$`

非零开头的最多带两位小数的数字：`^([1-9][0-9]*)+(.[0-9]{1,2})?$`

带1-2位小数的正数或负数：`^(\-)?\d+(\.\d{1,2})?$`

正数、负数、和小数：`^(\-|\+)?\d+(\.\d+)?$`

有两位小数的正实数：`^[0-9]+(.[0-9]{2})?$`

有1~3位小数的正实数：`^[0-9]+(.[0-9]{1,3})?$`

非零的正整数：`^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$`

非零的负整数：`^\-[1-9][]0-9"*$ 或 ^-[1-9]\d*$`
非负整数：`^\d+$ 或 ^[1-9]\d*|0$`

非正整数：`^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$`

非负浮点数：`^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$`

非正浮点数：`^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$`

正浮点数：`^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$`

负浮点数：`^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$`

浮点数：`^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$`

### 校验字符的表达式

汉字：`^[\u4e00-\u9fa5]{0,}$`

英文和数字：`^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$`

长度为3-20的所有字符：`^.{3,20}$`

由26个英文字母组成的字符串：`^[A-Za-z]+$`

由26个大写英文字母组成的字符串：`^[A-Z]+$`

由26个小写英文字母组成的字符串：`^[a-z]+$`

由数字和26个英文字母组成的字符串：`^[A-Za-z0-9]+$`

由数字、26个英文字母或者下划线组成的字符串：`^\w+$ 或 ^\w{3,20}`

中文、英文、数字包括下划线：`^[\u4E00-\u9FA5A-Za-z0-9_]+$`

中文、英文、数字但不包括下划线等符号：`^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$`

可以输入含有^%&',;=?\\" 等字符：\`\[^%&',;=?\\x22\]+\`

禁止输入含有~的字符`[^~\x22]+`

> 其它

```

.*匹配除 \n 以外的任何字符。/[\u4E00-\u9FA5]/ 汉字
/[\uFF00-\uFFFF]/ 全角符号
/[\u0000-\u00FF]/ 半角符号
```

### 特殊需求表达式

Email 地址：`^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$`

域名：`[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$`
手机号码：`^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$`
电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：`^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$`

国内电话号码(0511-4405222、021-87888822)：`\d{3}-\d{8}|\d{4}-\d{7}`

身份证号(15位、18位数字)：`^\d{15}|\d{18}$`

短身份证号码(数字、字母x结尾)：`^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$`

帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：`^[a-zA-Z][a-zA-Z0-9_]{4,15}$`

密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：`^[a-zA-Z]\w{5,17}$`

强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：`^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$`

日期格式：`^\d{4}-\d{1,2}-\d{1,2}`

一年的12个月(01～09和1～12)：`^(0?[1-9]|1[0-2])$`

一个月的31天(01～09和1～31)：`^((0?[1-9])|((1|2)[0-9])|30|31)$`

### 钱的输入格式

有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：`^[1-9][0-9]*$`

这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：`^(0|[1-9][0-9]*)$`

一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：`^(0|-?[1-9][0-9]*)$`

4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：`^[0-9]+(.[0-9]+)?$`

必须说明的是,小数点后面至少应该有1位数，所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：`^[0-9]+(.[0-9]{2})?$`

这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：`^[0-9]+(.[0-9]{1,2})?$`

这样就允许用户只写一位小数.下面我们该考虑数字中的 逗号 了，我们可以这样：`^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$`

1到3个数字,后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：`^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$`

> 备注：这就是最终结果了,别忘了+可以用\*替代如果你觉得空字符串也可以接受的话，最后,别忘了在用函数时去掉去掉那个反
> xml文件：`^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$`

中文字符的正则表达式：`[\u4e00-\u9fa5]`

双字节字符：`^\x00-\xff)`

空白行的正则表达式：`\n\s*\r (可以用来删除空白行)`

HTML标记的正则表达式：`<(\S?)[^>]>.?</\1>|<.? />`(网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)

首尾空白字符的正则表达式：`^\s|\s`
(可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)

腾讯QQ号：`[1-9][0-9]{4,}(腾讯QQ号从10000开始)`

中国邮政编码：`[1-9]\d{5}(?!\d)`(中国邮政编码为6位数字)

IP地址：`\d+.\d+.\d+.\d+`(提取IP地址时有用)

IP地址：`((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))`

IP-v4地址：`\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b`(提取IP地址时有用)
校验IP-v6地址:

```
(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))
```

子网掩码：

```
((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))
```

校验日期:

```
^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$("yyyy-mm-dd")
```

抽取注释：`<!--(.*?)-->`

查找CSS属性:`^\\s*[a-zA-Z\\-]+\\s*[:]{1}\\s[a-zA-Z0-9\\s.#]+[;]{1}`

提取页面超链接:`(<a\\s*(?!.*\\brel=)[^>]*)(href="https?:\\/\\/)((?!(?:(?:www\\.)?'.implode('|(?:www\\.)?', $follow_list).'))[^" rel="external nofollow" ]+)"((?!.*\\brel=)[^>]*)(?:[^>]*)>`

提取网页图片:`\\< *[img][^\\\\>]*[src] *= *[\\"\\']{0,1}([^\\"\\'\\ >]*)`

提取网页颜色代码:`^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$`

文件扩展名效验:`^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\/:*?"<>|]+\\.txt(l)?$`

判断IE版本：`^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\/[5-9]\\.0).*$`

***

# 总结

以上就是勇哥今天为各位小伙伴准备的内容，如果你想了解更多关于Python自动化测试的知识和技巧，欢迎关注：

我的公众号：百态测试

博客（[奈非天的主页 - 博客园 (cnblogs.com)](https://home.cnblogs.com/u/Nephalem-262667641)）

我会不定期地分享更多的精彩内容。感谢你的阅读和支持！

本文来自博客园，作者：[奈非天](https://www.cnblogs.com/Nephalem-262667641/)，转载请注明原文链接：[https://www.cnblogs.com/Nephalem-262667641/p/17460169.html](https://www.cnblogs.com/Nephalem-262667641/p/17460169.html)